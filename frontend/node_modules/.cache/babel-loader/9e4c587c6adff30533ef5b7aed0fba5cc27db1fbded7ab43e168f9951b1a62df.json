{"ast":null,"code":"// Variables\nlet score = 0;\nlet timerInterval;\nlet elapsedTime = 0;\nlet startTime;\nlet currentGameSessionId = null;\nconst gameData = {\n  holes: {},\n  // Track scores for each hole within the current loop\n  loopScores: [] // Store completed loop scores and details\n};\nexport function updateScoreDisplay() {\n  const scoreDisplay = document.getElementById('score-value');\n  if (score < 1000) {\n    scoreDisplay.textContent = score;\n  } else {\n    scoreDisplay.textContent = score.toLocaleString('en-US', {\n      minimumIntegerDigits: 4,\n      useGrouping: true\n    });\n  }\n}\nexport function resetScoreDisplay() {\n  score = 0;\n  updateScoreDisplay();\n}\nexport function stopTimeDisplay() {\n  clearInterval(timerInterval);\n}\nexport function resetTimeDisplay() {\n  clearInterval(timerInterval);\n  elapsedTime = 0;\n  updateTimeDisplay(0, 0, 0); // Initialize the time display to 00:00:00\n}\nexport function updateTimeDisplay(hours, minutes, seconds) {\n  const timeDisplay = document.getElementById('time-value');\n  hours = hours < 10 ? \"0\" + hours : hours;\n  minutes = minutes < 10 ? \"0\" + minutes : minutes;\n  seconds = seconds < 10 ? \"0\" + seconds : seconds;\n  timeDisplay.textContent = hours + \":\" + minutes + \":\" + seconds;\n}\nexport function startStopwatch() {\n  clearInterval(timerInterval); // Clear any existing interval\n  startTime = Date.now() - elapsedTime; // Set startTime to account for elapsed time\n\n  function updateTimer() {\n    elapsedTime = Date.now() - startTime; // Update elapsedTime\n    const hours = Math.floor(elapsedTime / (3600 * 1000));\n    const minutes = Math.floor(elapsedTime % (3600 * 1000) / (60 * 1000));\n    const seconds = Math.floor(elapsedTime % (60 * 1000) / 1000);\n    updateTimeDisplay(hours, minutes, seconds);\n  }\n  updateTimer(); // Update timer immediately\n  timerInterval = setInterval(updateTimer, 1000); // Update every second\n}\nexport function updateBallsValueDisplay(ballValue) {\n  const ballsValueDisplay = document.getElementById('balls-input');\n  ballsValueDisplay.value = ballValue;\n}\nexport function animateScoreIncrement(amount) {\n  let targetScore = score + amount;\n  let incrementSpeed = 0.1; // Increment speed in milliseconds\n\n  function increment() {\n    if (score < targetScore) {\n      score++;\n      updateScoreDisplay();\n      setTimeout(increment, incrementSpeed);\n    } else {\n      score = targetScore; // Ensure the score matches the target precisely\n      updateScoreDisplay();\n    }\n  }\n  increment();\n}\nexport function addHoleScore(holeNumber, holeScore) {\n  gameData.holes[holeNumber] = holeScore;\n}\n\n// Function to get the CSRF token from the cookies\nexport function getCSRFToken() {\n  const cookieValue = document.cookie.match('(^|;)\\\\s*csrftoken\\\\s*=\\\\s*([^;]+)');\n  return cookieValue ? cookieValue.pop() : '';\n}\n\n// Function to create a new game session\nexport function createNewGameSession() {\n  // Dynamically set the API base URL\n  let baseUrl = window.location.origin; // Will give you the correct domain (http://127.0.0.1:8000 or https://yourdomain.com)\n  // change the port of the baseUrl to 8000\n  baseUrl = baseUrl.replace('3000', '8000');\n  const apiUrl = `${baseUrl}/api/game-session/create/`; // Append your endpoint to the base URL\n\n  const payload = {\n    game: 1,\n    // Replace with your actual game ID\n    player: 1,\n    // Replace with your actual player ID\n    arcade: 1 // Replace with your actual arcade ID\n  };\n  const csrfToken = getCSRFToken(); // Get the CSRF token from the cookies\n\n  // Send the POST request to create the game session\n  fetch(apiUrl, {\n    method: 'POST',\n    headers: {\n      'Content-Type': 'application/json',\n      'X-CSRFToken': csrfToken // Include the CSRF token in the headers\n    },\n    body: JSON.stringify(payload)\n  }).then(response => response.json()).then(data => {\n    console.log('Game session created:', data);\n    if (data.game_session_id) {\n      // Store the session ID in the global variable\n      currentGameSessionId = data.game_session_id;\n    } else {\n      console.error('Game session creation response does not contain an ID.');\n    }\n  }).catch(error => {\n    console.error('Error creating game session:', error);\n  });\n}\n\n// Function to update the hole scores for a game session\nexport function updateGameSession(holeNumber, loopNumber, holeScore) {\n  if (!currentGameSessionId) {\n    console.error('Game session ID is not available. Cannot update hole scores.');\n    return;\n  }\n\n  // Dynamically set the API base URL\n  let baseUrl = window.location.origin; // Will give you the correct domain (http://127.0.0.1:8000 or https://yourdomain.com)\n  // change the port of the baseUrl to 8000\n  baseUrl = baseUrl.replace('3000', '8000');\n  const apiUrl = `${baseUrl}/api/game-session/${currentGameSessionId}/loop/${loopNumber}/hole/${holeNumber}/update-score/`; // Append your endpoint to the base URL\n\n  const payload = {\n    hole_score: holeScore\n  };\n  const csrfToken = getCSRFToken(); // Get the CSRF token from the cookies\n\n  // Send the PATCH request to update the hole score\n  fetch(apiUrl, {\n    method: 'PATCH',\n    headers: {\n      'Content-Type': 'application/json',\n      'X-CSRFToken': csrfToken // Include the CSRF token in the headers\n    },\n    body: JSON.stringify(payload)\n  }).then(response => response.json()).then(data => {\n    console.log('Hole score updated:', data);\n  }).catch(error => {\n    console.error('Error updating hole score:', error);\n  });\n}","map":{"version":3,"names":["score","timerInterval","elapsedTime","startTime","currentGameSessionId","gameData","holes","loopScores","updateScoreDisplay","scoreDisplay","document","getElementById","textContent","toLocaleString","minimumIntegerDigits","useGrouping","resetScoreDisplay","stopTimeDisplay","clearInterval","resetTimeDisplay","updateTimeDisplay","hours","minutes","seconds","timeDisplay","startStopwatch","Date","now","updateTimer","Math","floor","setInterval","updateBallsValueDisplay","ballValue","ballsValueDisplay","value","animateScoreIncrement","amount","targetScore","incrementSpeed","increment","setTimeout","addHoleScore","holeNumber","holeScore","getCSRFToken","cookieValue","cookie","match","pop","createNewGameSession","baseUrl","window","location","origin","replace","apiUrl","payload","game","player","arcade","csrfToken","fetch","method","headers","body","JSON","stringify","then","response","json","data","console","log","game_session_id","error","catch","updateGameSession","loopNumber","hole_score"],"sources":["/app/src/utils/api.js"],"sourcesContent":["// Variables\nlet score = 0;\nlet timerInterval;\nlet elapsedTime = 0;\nlet startTime;\nlet currentGameSessionId = null;\n\nconst gameData = {\n    holes: {}, // Track scores for each hole within the current loop\n    loopScores: [] // Store completed loop scores and details\n};\n\nexport function updateScoreDisplay() {\n    const scoreDisplay = document.getElementById('score-value');\n    if (score < 1000) {\n        scoreDisplay.textContent = score;\n    } else {\n        scoreDisplay.textContent = score.toLocaleString('en-US', { minimumIntegerDigits: 4, useGrouping: true });\n    }\n}\n\nexport function resetScoreDisplay() {\n    score = 0;\n    updateScoreDisplay();\n}\n\nexport function stopTimeDisplay() {\n    clearInterval(timerInterval);\n}\n\nexport function resetTimeDisplay() {\n    clearInterval(timerInterval);\n    elapsedTime = 0;\n    updateTimeDisplay(0, 0, 0); // Initialize the time display to 00:00:00\n}\n\nexport function updateTimeDisplay(hours, minutes, seconds) {\n    const timeDisplay = document.getElementById('time-value');\n    hours = hours < 10 ? \"0\" + hours : hours;\n    minutes = minutes < 10 ? \"0\" + minutes : minutes;\n    seconds = seconds < 10 ? \"0\" + seconds : seconds;\n    timeDisplay.textContent = hours + \":\" + minutes + \":\" + seconds;\n}\n\nexport function startStopwatch() {\n    clearInterval(timerInterval); // Clear any existing interval\n    startTime = Date.now() - elapsedTime; // Set startTime to account for elapsed time\n\n    function updateTimer() {\n        elapsedTime = Date.now() - startTime; // Update elapsedTime\n        const hours = Math.floor(elapsedTime / (3600 * 1000));\n        const minutes = Math.floor((elapsedTime % (3600 * 1000)) / (60 * 1000));\n        const seconds = Math.floor((elapsedTime % (60 * 1000)) / 1000);\n        updateTimeDisplay(hours, minutes, seconds);\n    }\n\n    updateTimer(); // Update timer immediately\n    timerInterval = setInterval(updateTimer, 1000); // Update every second\n}\n\nexport function updateBallsValueDisplay(ballValue) {\n    const ballsValueDisplay = document.getElementById('balls-input');\n    ballsValueDisplay.value = ballValue;\n}\n\nexport function animateScoreIncrement(amount) {\n    let targetScore = score + amount;\n    let incrementSpeed = 0.1; // Increment speed in milliseconds\n\n    function increment() {\n        if (score < targetScore) {\n            score++;\n            updateScoreDisplay();\n            setTimeout(increment, incrementSpeed);\n        } else {\n            score = targetScore; // Ensure the score matches the target precisely\n            updateScoreDisplay();\n        }\n    }\n\n    increment();\n}\n\nexport function addHoleScore(holeNumber, holeScore) {\n    gameData.holes[holeNumber] = holeScore;\n}\n\n// Function to get the CSRF token from the cookies\nexport function getCSRFToken() {\n    const cookieValue = document.cookie.match('(^|;)\\\\s*csrftoken\\\\s*=\\\\s*([^;]+)');\n    return cookieValue ? cookieValue.pop() : '';\n}\n\n// Function to create a new game session\nexport function createNewGameSession() {\n    // Dynamically set the API base URL\n    let baseUrl = window.location.origin; // Will give you the correct domain (http://127.0.0.1:8000 or https://yourdomain.com)\n    // change the port of the baseUrl to 8000\n    baseUrl = baseUrl.replace('3000', '8000');\n    const apiUrl = `${baseUrl}/api/game-session/create/`; // Append your endpoint to the base URL\n\n    const payload = {\n        game: 1, // Replace with your actual game ID\n        player: 1, // Replace with your actual player ID\n        arcade: 1 // Replace with your actual arcade ID\n    };\n\n    const csrfToken = getCSRFToken(); // Get the CSRF token from the cookies\n\n    // Send the POST request to create the game session\n    fetch(apiUrl, {\n        method: 'POST',\n        headers: {\n            'Content-Type': 'application/json',\n            'X-CSRFToken': csrfToken, // Include the CSRF token in the headers\n        },\n        body: JSON.stringify(payload),\n    })\n    .then(response => response.json())\n    .then(data => {\n        console.log('Game session created:', data);\n\n        if (data.game_session_id) {\n            // Store the session ID in the global variable\n            currentGameSessionId = data.game_session_id;\n        } else {\n            console.error('Game session creation response does not contain an ID.');\n        }\n    })\n    .catch(error => {\n        console.error('Error creating game session:', error);\n    });\n}\n\n// Function to update the hole scores for a game session\nexport function updateGameSession(holeNumber, loopNumber, holeScore) {\n    if (!currentGameSessionId) {\n        console.error('Game session ID is not available. Cannot update hole scores.');\n        return;\n    }\n\n    // Dynamically set the API base URL\n    let baseUrl = window.location.origin; // Will give you the correct domain (http://127.0.0.1:8000 or https://yourdomain.com)\n    // change the port of the baseUrl to 8000\n    baseUrl = baseUrl.replace('3000', '8000');\n    const apiUrl = `${baseUrl}/api/game-session/${currentGameSessionId}/loop/${loopNumber}/hole/${holeNumber}/update-score/`; // Append your endpoint to the base URL\n\n    const payload = {\n        hole_score: holeScore\n    };\n\n    const csrfToken = getCSRFToken(); // Get the CSRF token from the cookies\n\n    // Send the PATCH request to update the hole score\n    fetch(apiUrl, {\n        method: 'PATCH',\n        headers: {\n            'Content-Type': 'application/json',\n            'X-CSRFToken': csrfToken, // Include the CSRF token in the headers\n        },\n        body: JSON.stringify(payload),\n    })\n    .then(response => response.json())\n    .then(data => {\n        console.log('Hole score updated:', data);\n    })\n    .catch(error => {\n        console.error('Error updating hole score:', error);\n    });\n}"],"mappings":"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","ignoreList":[]},"metadata":{},"sourceType":"module","externalDependencies":[]}